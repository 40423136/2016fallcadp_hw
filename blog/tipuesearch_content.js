var tipuesearch = {"pages":[{"url":"./pages/about/","title":"About","tags":"misc","text":"2016Fall 修課成員網誌"},{"url":"./2017fall-112.html","title":"2017Fall 1/12","tags":"Misc","text":"期末考自評~"},{"url":"./2016fall-1215.html","title":"2016Fall 12/15","tags":"Misc","text":"TUTORIAL: ASSEMBLIES In this tutorial, we will take multiple parts, and combine them into a parametric assembly. We will place the parts within the assembly using constraints. Once we've defined the assembly, we can verify that no parts interfere with each other, and generate multiple 2d or 3d representations of that assembly. With a careful choice of constraints, we will define the assembly in such a way as to permit us to modify the original parts, and have those changes propagate correctly into our assembly. Any SolveSpace file can be imported into any other SolveSpace file; there is no special type for parts or assemblies. This means that sub-assemblies, for example, work in the obvious way. We could draw any of our parts from scratch, but they are also available for download pre-drawn: box-parts.zip Extract these files to a directory somewhere on your computer. It's possible to import files from any directory into any file, but for simplicity it is best to put the parts and assembly in a single directory. If we do this, then we can copy that single directory to another computer and retain all the parametric links between the files. We can open any of these files to view them. All of these are simple 2d parts, that could be laser-cut or three-axis milled from 6mm or 3/8\" acrylic. They are designed to assemble with tabs in slots, to form a box with six compartments: We wish to assemble these parts—a base, two sides, and seven dividers—into that box. To do so, we will begin with the base. (Of course, we could begin with any component that we wanted. But it's logical to begin with the base.) Create a new file in SolveSpace by choosing File → New. In that new file, choose New Group → Import / Assemble. Specify the base.slvs file that you just saved on your computer. (You may also use New Group → Import Recent, if base.slvs appears in that list. This is exactly equivalent.) The part will appear in our assembly. We can grab any point with the mouse, and left-drag; the entire part will move along with us, within the plane of the screen. We can rotate our view of the part (in the usual way, by center-dragging with the mouse) to see where we've dragged the part in 3d. So by left-dragging points on the model, we can translate the part within the assembly. We also can grab a point with the mouse, and Shift+left-drag. This rotates the part into and out of the plane of the screen, about that point. We can similarly rotate the part by left-dragging any of the blue arrows that represent normals. And to rotate the part within the plane of the screen, we can Ctrl+left-drag either a point or a normal. It's difficult to precisely define the orientation or position of a part within an assembly using the mouse. So it's best to just place the part roughly, and then define its exact position using constraints. To start, place the base in roughly the position shown above, close to the coordinate axes. The X, Y, and Z axes are drawn as dark red, green, and blue arrows here respectively. (The coordinate axes also appear at the bottom left of the graphics window at all times, drawn in bright red, green, and blue. They behave identically no matter which copy is used.) To start, we would like to define the orientation of the part. We can do that by locking one of the part's normals in the same orientation as one of our coordinate axes. Here, a good choice would be to constrain any of the base's normals—which are drawn as blue arrows—in the same orientation as our coordinate system's Z axis, which is also drawn as a blue arrow, in this view pointing approximately up from the origin. Select those two normals by left-clicking them, and choose Constrain → Same Orientation, or the equivalent constraint from the toolbar. The two normals are now each marked with a magenta X, which is visible above. (It doesn't matter which of the normals on the part were chosen to constrain, since they all point in the same direction. The choice is arbitrary.) This means that those two normals are constrained to point in the same direction (i.e., parallel); but it also locks the twist of the part about that axis, so it fully constrains the part's orientation. The same-orientation constraint is useful, because it completely specifies a part's orientation with a single constraint. We can try to drag the part's orientation and rotation now. We will find that it is still possible to translate the part anywhere, but impossible to rotate it, because that rotation is now fixed. To define the translation, we can use a point-coincident constraint. Select the two points marked in red in the image above, and choose Constrain → On Point. The two points will now be constrained to be coincident, locking the imported part's translation. The imported part is now fully constrained. Next, we wish to place the seven dividers. We will again choose New Group → Import / Assemble, and specify divider.slvs. The divider will appear in our assembly, initially with the wrong position and orientation. We therefore must drag it into roughly the position indicated below, with the longer of the divider's two tabs aligned to the slot on the base. We can do this with the mouse, by left-dragging the position and Shift+left-dragging the orientation. It may also be useful to choose Edit → Rotate Imported 90°, to rotate the imported part by exactly ninety degrees about the coordinate axis that's closest to normal to the screen. (So if we are looking onto the XY plane, for example, then it rotates the part about the Z axis.) As before, we can lock the orientation of the divider with a same-orientation constraint on one of its normals. One possible choice is to lock a normal on the divider against our coordinate system's X axis, which is drawn in red. The magenta X marks are again visible on the image below, indicating the two normals that are in the same orientation. And we have again indicated two points in red that could be constrained coincident to define the position of the part. Select those two points by left-clicking them, and choose Constrain → On Point. The divider is now fully constrained. We could repeat this process six more times, to place the seven dividers. But it's easier to step and repeat our one imported part seven times. So choose New Group → Step and Repeat Translating. By default, three copies of the original part will appear, stepped along some constant distance and direction: Note that we have now hidden points and normals, by clicking the respective icons at the top of the text window. The assembly is getting more complex, so those were cluttering the screen. We can show or hide those as desired at any time. In the step and repeat group's text window screen (press Tab to show that window if it is hidden), we can change the number of times repeated to seven. We now see seven copies of that divider. We can drag these copies with the mouse. The first one is locked, and the orientation of all of them is locked (since the first copy's orientation is locked, and the copies have a different translation but the same rotation). But by dragging any of the other copies, we can change the translation distance and direction for the step and repeat. We can drag the parts into roughly the correct position, and then, as usual, place the exact position using a constraint. Above, select the two points that are shown marked in red. (Even when points are hidden, they will appear when the mouse is hovered over them, and may be selected by left-clicking in the usual way.) Constrain those two points coincident, and the seven dividers will be placed as desired. Finally, we wish to place the two sides. We choose New Group → Import / Assemble as usual, and specify side.slvs. It appears within our assembly with some arbitrary position and orientation, which are probably not what's desired. In this particular default position and orientation, it is interfering with other parts in the assembly. This is obvious, though we could choose Analyze → Show Interfering Parts to confirm that. Press Esc to clear the red error lines. Drag and rotate the side into roughly the position indicated below; once again, Edit → Rotate Imported 90° may be a better way to define the orientation than by Shift+left-dragging with the mouse. Once again, constrain the orientation of the imported part using a same-orientation constraint, for example on one of that part's normals against our coordinate system's Y axis (drawn in green). Note that it does not matter if the Y axis and part's normal are pointing in exactly opposite directions; the constraint will constrain them either parallel or anti-parallel, depending on which is closer to the initial configuration. We could again use a point-coincident constraint to define the orientation of the part, and that would in fact be the simplest way to do so. But to illustrate different types of constraint, we will instead use three point-on-face constraints. The plane faces of the parts are selectable; they are highlighted with a yellow stipple pattern when the mouse hovers over them, and appear with a red stipple pattern when they are selected. Here, we have selected a face on the inside of one of the slots on the green side, and a point on the orange divider. If it is difficult to select the faces because other entities are getting highlighted instead, then try zooming in more. Select Constrain → On Plane; the part may now move only in such a way as to maintain that point within the plane of that face. Rotate the view into several different orientations (by middle-dragging with the mouse) and try dragging the part. As drawn here, it will be possible to move the part in the Y and Z directions, but not the X direction. So if the view is roughly aligned to the YZ plane, for example, then the part will seem to have two degrees of freedom, but if the view is aligned to the XY plane then it will seem to have only one. Of course, the part actually has two degrees of freedom; it started with three translational degrees of freedom, and the point-on-face constraint has subtracted one. Next, select the plane of the top of the grey base and a point on the bottom of the green side, as indicated in the image above. Again choose Constrain → On Plane. The part now has only one degree of freedom, and may be dragged only parallel to the Y axis. Finally, select the outer face of the green side, and a point on the outside of one of the orange divider's tabs, as indicated below. Again constrain the point on the face. The green side's position is now locked. Point-on-face constraints are useful when constraining assemblies, because each constraint subtracts only a single degree of freedom. This is useful when constraining an assembly only partially, for example if we wish to drag the parts and produce an exploded view. It's often difficult to drag a part's three degrees of freedom if its position is left completely unconstrained, but if the part is constrained with only a single degree of freedom, then it's possible to drag that one degree of freedom with less confusion. Parts may be placed with any constraint in SolveSpace, not just point-coincident or point-on-face constraints. Those two constraints are typically the most useful, though. A point-on-line constraint, for example, subtracts two degrees of freedom. This means that two point-on-line constraints are an error, since they must overconstrain the part (which has only three translational degrees of freedom, when the two constraints are trying to subtract four degrees of freedom). The combination of a point-on-line constraint and a point-on-face would be correct (2+1 DOF), or a point-on-line constraint plus a point-on-line constraint projected into a workplane (since the projected version of the constraint removes only one degree of freedom), or many others. It's possible to constrain the position and orientation of parts in SolveSpace in many different ways. In general, though, it should almost always be possible to constrain the parts with same-orientation, point-coincident, and point-on-face constraints only. Note in particular that it's not possible to place the position and orientation (six degrees of freedom) of a part using two point-coincident constraints. It seems like this should work, because the part initially has six degrees of freedom, and each point-coincident constraint removes three degrees of freedom. But the part, with those constraints, would obviously still be free to rotate about the line connecting the two constrained points. So that combination of constraints fails to fully constrain the part's rotation, and overconstrains the part elsewhere. It is therefore invalid. Place the other side of the box by any method; for example by importing it again and using a same-orientation and point-coincident constraint, or by stepping and repeating the side that we've just place twice, or in some other way. The assembly is now complete. We can view it on-screen, and produce isometric (View → Nearest Isometric View) or top, bottom and side (View → Nearest Ortho View) views of all the parts. We can suppress the display of a part by changing that setting in its text window screen. For example, to hide the base, we would click the home link at the top of the text window, and then choose its group—which in our assembly was the first import group, g003-import—from the list of groups. We then click the box labeled \"suppress this group's solid model\" to check it. To show that part again, we click that box again to uncheck it. We can verify that no parts interfere by choosing Analyze → Show Interfering Parts. If any parts interfere, then red lines will be drawn to indicate the location of the interference. (Note that this operation works on the triangle mesh, and not the exact NURBS surfaces; this means that it is guaranteed to work only for plane surfaces, and might report an erroneous interference for a round pin in a round hole.) Note that Analyze → Show Naked Edges will show many errors. This is expected, and not a problem. In our assembly, we have many places where two parts lie against each other exactly. The parts are supposed to fit together exactly, so this is the desired behavior; but a mesh that has two triangles exactly coplanar with each other is an error, so the \"STL check\" properly fails. For assemblies, Show Naked Edges is not typically meaningful; use Show Interfering Parts instead. We can export views of the assembly in the same way that we would export a view of a part. For example, we can choose File → Export View to produce a hidden-line-removed PDF, as shown below. (We had been working with parallel projections of the model so far, but this drawing has some perspective. We added this by choosing View → Use Perspective Projection. To adjust the amount of perspective, change the perspective factor in the configuration screen. The configuration screen is reachable from the link at the bottom of the home screen in the text window.) We can make changes to one of the parts, and then regenerate the assembly (by choosing Edit → Regenerate All, or by closing and reopening the file). The changes will propagate into our assembly, and with a careful choice of constraints, the parts will remain assembled in the desired configuration. This completes our tutorial. The assembly is also available for download: box-asm.zip Note that if you download the assembly, then it is necessary to extract all the part files to the same directory as the assembly file before attempting to open the assembly file. The assembly file does not contain a copy of the parts, so the program must rescan the part files every time it regenerates. To learn more about SolveSpace, including the assembly features, see the other tutorials or the reference manual."},{"url":"./2016fall-1201.html","title":"2016Fall 12/01","tags":"Misc","text":"TUTORIAL: ASSEMBLIES In this tutorial, we will take multiple parts, and combine them into a parametric assembly. We will place the parts within the assembly using constraints. Once we've defined the assembly, we can verify that no parts interfere with each other, and generate multiple 2d or 3d representations of that assembly. With a careful choice of constraints, we will define the assembly in such a way as to permit us to modify the original parts, and have those changes propagate correctly into our assembly. Any SolveSpace file can be imported into any other SolveSpace file; there is no special type for parts or assemblies. This means that sub-assemblies, for example, work in the obvious way. We could draw any of our parts from scratch, but they are also available for download pre-drawn: box-parts.zip Extract these files to a directory somewhere on your computer. It's possible to import files from any directory into any file, but for simplicity it is best to put the parts and assembly in a single directory. If we do this, then we can copy that single directory to another computer and retain all the parametric links between the files. We can open any of these files to view them. All of these are simple 2d parts, that could be laser-cut or three-axis milled from 6mm or 3/8\" acrylic. They are designed to assemble with tabs in slots, to form a box with six compartments: We wish to assemble these parts—a base, two sides, and seven dividers—into that box. To do so, we will begin with the base. (Of course, we could begin with any component that we wanted. But it's logical to begin with the base.) Create a new file in SolveSpace by choosing File → New. In that new file, choose New Group → Import / Assemble. Specify the base.slvs file that you just saved on your computer. (You may also use New Group → Import Recent, if base.slvs appears in that list. This is exactly equivalent.) The part will appear in our assembly. We can grab any point with the mouse, and left-drag; the entire part will move along with us, within the plane of the screen. We can rotate our view of the part (in the usual way, by center-dragging with the mouse) to see where we've dragged the part in 3d. So by left-dragging points on the model, we can translate the part within the assembly. We also can grab a point with the mouse, and Shift+left-drag. This rotates the part into and out of the plane of the screen, about that point. We can similarly rotate the part by left-dragging any of the blue arrows that represent normals. And to rotate the part within the plane of the screen, we can Ctrl+left-drag either a point or a normal. It's difficult to precisely define the orientation or position of a part within an assembly using the mouse. So it's best to just place the part roughly, and then define its exact position using constraints. To start, place the base in roughly the position shown above, close to the coordinate axes. The X, Y, and Z axes are drawn as dark red, green, and blue arrows here respectively. (The coordinate axes also appear at the bottom left of the graphics window at all times, drawn in bright red, green, and blue. They behave identically no matter which copy is used.) To start, we would like to define the orientation of the part. We can do that by locking one of the part's normals in the same orientation as one of our coordinate axes. Here, a good choice would be to constrain any of the base's normals—which are drawn as blue arrows—in the same orientation as our coordinate system's Z axis, which is also drawn as a blue arrow, in this view pointing approximately up from the origin. Select those two normals by left-clicking them, and choose Constrain → Same Orientation, or the equivalent constraint from the toolbar. The two normals are now each marked with a magenta X, which is visible above. (It doesn't matter which of the normals on the part were chosen to constrain, since they all point in the same direction. The choice is arbitrary.) This means that those two normals are constrained to point in the same direction (i.e., parallel); but it also locks the twist of the part about that axis, so it fully constrains the part's orientation. The same-orientation constraint is useful, because it completely specifies a part's orientation with a single constraint. We can try to drag the part's orientation and rotation now. We will find that it is still possible to translate the part anywhere, but impossible to rotate it, because that rotation is now fixed. To define the translation, we can use a point-coincident constraint. Select the two points marked in red in the image above, and choose Constrain → On Point. The two points will now be constrained to be coincident, locking the imported part's translation. The imported part is now fully constrained. Next, we wish to place the seven dividers. We will again choose New Group → Import / Assemble, and specify divider.slvs. The divider will appear in our assembly, initially with the wrong position and orientation. We therefore must drag it into roughly the position indicated below, with the longer of the divider's two tabs aligned to the slot on the base. We can do this with the mouse, by left-dragging the position and Shift+left-dragging the orientation. It may also be useful to choose Edit → Rotate Imported 90°, to rotate the imported part by exactly ninety degrees about the coordinate axis that's closest to normal to the screen. (So if we are looking onto the XY plane, for example, then it rotates the part about the Z axis.) As before, we can lock the orientation of the divider with a same-orientation constraint on one of its normals. One possible choice is to lock a normal on the divider against our coordinate system's X axis, which is drawn in red. The magenta X marks are again visible on the image below, indicating the two normals that are in the same orientation. And we have again indicated two points in red that could be constrained coincident to define the position of the part. Select those two points by left-clicking them, and choose Constrain → On Point. The divider is now fully constrained. We could repeat this process six more times, to place the seven dividers. But it's easier to step and repeat our one imported part seven times. So choose New Group → Step and Repeat Translating. By default, three copies of the original part will appear, stepped along some constant distance and direction: Note that we have now hidden points and normals, by clicking the respective icons at the top of the text window. The assembly is getting more complex, so those were cluttering the screen. We can show or hide those as desired at any time. In the step and repeat group's text window screen (press Tab to show that window if it is hidden), we can change the number of times repeated to seven. We now see seven copies of that divider. We can drag these copies with the mouse. The first one is locked, and the orientation of all of them is locked (since the first copy's orientation is locked, and the copies have a different translation but the same rotation). But by dragging any of the other copies, we can change the translation distance and direction for the step and repeat. We can drag the parts into roughly the correct position, and then, as usual, place the exact position using a constraint. Above, select the two points that are shown marked in red. (Even when points are hidden, they will appear when the mouse is hovered over them, and may be selected by left-clicking in the usual way.) Constrain those two points coincident, and the seven dividers will be placed as desired. Finally, we wish to place the two sides. We choose New Group → Import / Assemble as usual, and specify side.slvs. It appears within our assembly with some arbitrary position and orientation, which are probably not what's desired. In this particular default position and orientation, it is interfering with other parts in the assembly. This is obvious, though we could choose Analyze → Show Interfering Parts to confirm that. Press Esc to clear the red error lines. Drag and rotate the side into roughly the position indicated below; once again, Edit → Rotate Imported 90° may be a better way to define the orientation than by Shift+left-dragging with the mouse. Once again, constrain the orientation of the imported part using a same-orientation constraint, for example on one of that part's normals against our coordinate system's Y axis (drawn in green). Note that it does not matter if the Y axis and part's normal are pointing in exactly opposite directions; the constraint will constrain them either parallel or anti-parallel, depending on which is closer to the initial configuration. We could again use a point-coincident constraint to define the orientation of the part, and that would in fact be the simplest way to do so. But to illustrate different types of constraint, we will instead use three point-on-face constraints. The plane faces of the parts are selectable; they are highlighted with a yellow stipple pattern when the mouse hovers over them, and appear with a red stipple pattern when they are selected. Here, we have selected a face on the inside of one of the slots on the green side, and a point on the orange divider. If it is difficult to select the faces because other entities are getting highlighted instead, then try zooming in more. Select Constrain → On Plane; the part may now move only in such a way as to maintain that point within the plane of that face. Rotate the view into several different orientations (by middle-dragging with the mouse) and try dragging the part. As drawn here, it will be possible to move the part in the Y and Z directions, but not the X direction. So if the view is roughly aligned to the YZ plane, for example, then the part will seem to have two degrees of freedom, but if the view is aligned to the XY plane then it will seem to have only one. Of course, the part actually has two degrees of freedom; it started with three translational degrees of freedom, and the point-on-face constraint has subtracted one. Next, select the plane of the top of the grey base and a point on the bottom of the green side, as indicated in the image above. Again choose Constrain → On Plane. The part now has only one degree of freedom, and may be dragged only parallel to the Y axis. Finally, select the outer face of the green side, and a point on the outside of one of the orange divider's tabs, as indicated below. Again constrain the point on the face. The green side's position is now locked. Point-on-face constraints are useful when constraining assemblies, because each constraint subtracts only a single degree of freedom. This is useful when constraining an assembly only partially, for example if we wish to drag the parts and produce an exploded view. It's often difficult to drag a part's three degrees of freedom if its position is left completely unconstrained, but if the part is constrained with only a single degree of freedom, then it's possible to drag that one degree of freedom with less confusion. Parts may be placed with any constraint in SolveSpace, not just point-coincident or point-on-face constraints. Those two constraints are typically the most useful, though. A point-on-line constraint, for example, subtracts two degrees of freedom. This means that two point-on-line constraints are an error, since they must overconstrain the part (which has only three translational degrees of freedom, when the two constraints are trying to subtract four degrees of freedom). The combination of a point-on-line constraint and a point-on-face would be correct (2+1 DOF), or a point-on-line constraint plus a point-on-line constraint projected into a workplane (since the projected version of the constraint removes only one degree of freedom), or many others. It's possible to constrain the position and orientation of parts in SolveSpace in many different ways. In general, though, it should almost always be possible to constrain the parts with same-orientation, point-coincident, and point-on-face constraints only. Note in particular that it's not possible to place the position and orientation (six degrees of freedom) of a part using two point-coincident constraints. It seems like this should work, because the part initially has six degrees of freedom, and each point-coincident constraint removes three degrees of freedom. But the part, with those constraints, would obviously still be free to rotate about the line connecting the two constrained points. So that combination of constraints fails to fully constrain the part's rotation, and overconstrains the part elsewhere. It is therefore invalid. Place the other side of the box by any method; for example by importing it again and using a same-orientation and point-coincident constraint, or by stepping and repeating the side that we've just place twice, or in some other way. The assembly is now complete. We can view it on-screen, and produce isometric (View → Nearest Isometric View) or top, bottom and side (View → Nearest Ortho View) views of all the parts. We can suppress the display of a part by changing that setting in its text window screen. For example, to hide the base, we would click the home link at the top of the text window, and then choose its group—which in our assembly was the first import group, g003-import—from the list of groups. We then click the box labeled \"suppress this group's solid model\" to check it. To show that part again, we click that box again to uncheck it. We can verify that no parts interfere by choosing Analyze → Show Interfering Parts. If any parts interfere, then red lines will be drawn to indicate the location of the interference. (Note that this operation works on the triangle mesh, and not the exact NURBS surfaces; this means that it is guaranteed to work only for plane surfaces, and might report an erroneous interference for a round pin in a round hole.) Note that Analyze → Show Naked Edges will show many errors. This is expected, and not a problem. In our assembly, we have many places where two parts lie against each other exactly. The parts are supposed to fit together exactly, so this is the desired behavior; but a mesh that has two triangles exactly coplanar with each other is an error, so the \"STL check\" properly fails. For assemblies, Show Naked Edges is not typically meaningful; use Show Interfering Parts instead. We can export views of the assembly in the same way that we would export a view of a part. For example, we can choose File → Export View to produce a hidden-line-removed PDF, as shown below. (We had been working with parallel projections of the model so far, but this drawing has some perspective. We added this by choosing View → Use Perspective Projection. To adjust the amount of perspective, change the perspective factor in the configuration screen. The configuration screen is reachable from the link at the bottom of the home screen in the text window.) We can make changes to one of the parts, and then regenerate the assembly (by choosing Edit → Regenerate All, or by closing and reopening the file). The changes will propagate into our assembly, and with a careful choice of constraints, the parts will remain assembled in the desired configuration. This completes our tutorial. The assembly is also available for download: box-asm.zip Note that if you download the assembly, then it is necessary to extract all the part files to the same directory as the assembly file before attempting to open the assembly file. The assembly file does not contain a copy of the parts, so the program must rescan the part files every time it regenerates. To learn more about SolveSpace, including the assembly features, see the other tutorials or the reference manual."},{"url":"./2016fall-1124.html","title":"2016Fall 11/24","tags":"Misc","text":"TUTORIAL: ASSEMBLIES In this tutorial, we will take multiple parts, and combine them into a parametric assembly. We will place the parts within the assembly using constraints. Once we've defined the assembly, we can verify that no parts interfere with each other, and generate multiple 2d or 3d representations of that assembly. With a careful choice of constraints, we will define the assembly in such a way as to permit us to modify the original parts, and have those changes propagate correctly into our assembly. Any SolveSpace file can be imported into any other SolveSpace file; there is no special type for parts or assemblies. This means that sub-assemblies, for example, work in the obvious way. We could draw any of our parts from scratch, but they are also available for download pre-drawn: box-parts.zip Extract these files to a directory somewhere on your computer. It's possible to import files from any directory into any file, but for simplicity it is best to put the parts and assembly in a single directory. If we do this, then we can copy that single directory to another computer and retain all the parametric links between the files. We can open any of these files to view them. All of these are simple 2d parts, that could be laser-cut or three-axis milled from 6mm or 3/8\" acrylic. They are designed to assemble with tabs in slots, to form a box with six compartments: We wish to assemble these parts—a base, two sides, and seven dividers—into that box. To do so, we will begin with the base. (Of course, we could begin with any component that we wanted. But it's logical to begin with the base.) Create a new file in SolveSpace by choosing File → New. In that new file, choose New Group → Import / Assemble. Specify the base.slvs file that you just saved on your computer. (You may also use New Group → Import Recent, if base.slvs appears in that list. This is exactly equivalent.) The part will appear in our assembly. We can grab any point with the mouse, and left-drag; the entire part will move along with us, within the plane of the screen. We can rotate our view of the part (in the usual way, by center-dragging with the mouse) to see where we've dragged the part in 3d. So by left-dragging points on the model, we can translate the part within the assembly. We also can grab a point with the mouse, and Shift+left-drag. This rotates the part into and out of the plane of the screen, about that point. We can similarly rotate the part by left-dragging any of the blue arrows that represent normals. And to rotate the part within the plane of the screen, we can Ctrl+left-drag either a point or a normal. It's difficult to precisely define the orientation or position of a part within an assembly using the mouse. So it's best to just place the part roughly, and then define its exact position using constraints. To start, place the base in roughly the position shown above, close to the coordinate axes. The X, Y, and Z axes are drawn as dark red, green, and blue arrows here respectively. (The coordinate axes also appear at the bottom left of the graphics window at all times, drawn in bright red, green, and blue. They behave identically no matter which copy is used.) To start, we would like to define the orientation of the part. We can do that by locking one of the part's normals in the same orientation as one of our coordinate axes. Here, a good choice would be to constrain any of the base's normals—which are drawn as blue arrows—in the same orientation as our coordinate system's Z axis, which is also drawn as a blue arrow, in this view pointing approximately up from the origin. Select those two normals by left-clicking them, and choose Constrain → Same Orientation, or the equivalent constraint from the toolbar. The two normals are now each marked with a magenta X, which is visible above. (It doesn't matter which of the normals on the part were chosen to constrain, since they all point in the same direction. The choice is arbitrary.) This means that those two normals are constrained to point in the same direction (i.e., parallel); but it also locks the twist of the part about that axis, so it fully constrains the part's orientation. The same-orientation constraint is useful, because it completely specifies a part's orientation with a single constraint. We can try to drag the part's orientation and rotation now. We will find that it is still possible to translate the part anywhere, but impossible to rotate it, because that rotation is now fixed. To define the translation, we can use a point-coincident constraint. Select the two points marked in red in the image above, and choose Constrain → On Point. The two points will now be constrained to be coincident, locking the imported part's translation. The imported part is now fully constrained. Next, we wish to place the seven dividers. We will again choose New Group → Import / Assemble, and specify divider.slvs. The divider will appear in our assembly, initially with the wrong position and orientation. We therefore must drag it into roughly the position indicated below, with the longer of the divider's two tabs aligned to the slot on the base. We can do this with the mouse, by left-dragging the position and Shift+left-dragging the orientation. It may also be useful to choose Edit → Rotate Imported 90°, to rotate the imported part by exactly ninety degrees about the coordinate axis that's closest to normal to the screen. (So if we are looking onto the XY plane, for example, then it rotates the part about the Z axis.) As before, we can lock the orientation of the divider with a same-orientation constraint on one of its normals. One possible choice is to lock a normal on the divider against our coordinate system's X axis, which is drawn in red. The magenta X marks are again visible on the image below, indicating the two normals that are in the same orientation. And we have again indicated two points in red that could be constrained coincident to define the position of the part. Select those two points by left-clicking them, and choose Constrain → On Point. The divider is now fully constrained. We could repeat this process six more times, to place the seven dividers. But it's easier to step and repeat our one imported part seven times. So choose New Group → Step and Repeat Translating. By default, three copies of the original part will appear, stepped along some constant distance and direction: Note that we have now hidden points and normals, by clicking the respective icons at the top of the text window. The assembly is getting more complex, so those were cluttering the screen. We can show or hide those as desired at any time. In the step and repeat group's text window screen (press Tab to show that window if it is hidden), we can change the number of times repeated to seven. We now see seven copies of that divider. We can drag these copies with the mouse. The first one is locked, and the orientation of all of them is locked (since the first copy's orientation is locked, and the copies have a different translation but the same rotation). But by dragging any of the other copies, we can change the translation distance and direction for the step and repeat. We can drag the parts into roughly the correct position, and then, as usual, place the exact position using a constraint. Above, select the two points that are shown marked in red. (Even when points are hidden, they will appear when the mouse is hovered over them, and may be selected by left-clicking in the usual way.) Constrain those two points coincident, and the seven dividers will be placed as desired. Finally, we wish to place the two sides. We choose New Group → Import / Assemble as usual, and specify side.slvs. It appears within our assembly with some arbitrary position and orientation, which are probably not what's desired. In this particular default position and orientation, it is interfering with other parts in the assembly. This is obvious, though we could choose Analyze → Show Interfering Parts to confirm that. Press Esc to clear the red error lines. Drag and rotate the side into roughly the position indicated below; once again, Edit → Rotate Imported 90° may be a better way to define the orientation than by Shift+left-dragging with the mouse. Once again, constrain the orientation of the imported part using a same-orientation constraint, for example on one of that part's normals against our coordinate system's Y axis (drawn in green). Note that it does not matter if the Y axis and part's normal are pointing in exactly opposite directions; the constraint will constrain them either parallel or anti-parallel, depending on which is closer to the initial configuration. We could again use a point-coincident constraint to define the orientation of the part, and that would in fact be the simplest way to do so. But to illustrate different types of constraint, we will instead use three point-on-face constraints. The plane faces of the parts are selectable; they are highlighted with a yellow stipple pattern when the mouse hovers over them, and appear with a red stipple pattern when they are selected. Here, we have selected a face on the inside of one of the slots on the green side, and a point on the orange divider. If it is difficult to select the faces because other entities are getting highlighted instead, then try zooming in more. Select Constrain → On Plane; the part may now move only in such a way as to maintain that point within the plane of that face. Rotate the view into several different orientations (by middle-dragging with the mouse) and try dragging the part. As drawn here, it will be possible to move the part in the Y and Z directions, but not the X direction. So if the view is roughly aligned to the YZ plane, for example, then the part will seem to have two degrees of freedom, but if the view is aligned to the XY plane then it will seem to have only one. Of course, the part actually has two degrees of freedom; it started with three translational degrees of freedom, and the point-on-face constraint has subtracted one. Next, select the plane of the top of the grey base and a point on the bottom of the green side, as indicated in the image above. Again choose Constrain → On Plane. The part now has only one degree of freedom, and may be dragged only parallel to the Y axis. Finally, select the outer face of the green side, and a point on the outside of one of the orange divider's tabs, as indicated below. Again constrain the point on the face. The green side's position is now locked. Point-on-face constraints are useful when constraining assemblies, because each constraint subtracts only a single degree of freedom. This is useful when constraining an assembly only partially, for example if we wish to drag the parts and produce an exploded view. It's often difficult to drag a part's three degrees of freedom if its position is left completely unconstrained, but if the part is constrained with only a single degree of freedom, then it's possible to drag that one degree of freedom with less confusion. Parts may be placed with any constraint in SolveSpace, not just point-coincident or point-on-face constraints. Those two constraints are typically the most useful, though. A point-on-line constraint, for example, subtracts two degrees of freedom. This means that two point-on-line constraints are an error, since they must overconstrain the part (which has only three translational degrees of freedom, when the two constraints are trying to subtract four degrees of freedom). The combination of a point-on-line constraint and a point-on-face would be correct (2+1 DOF), or a point-on-line constraint plus a point-on-line constraint projected into a workplane (since the projected version of the constraint removes only one degree of freedom), or many others. It's possible to constrain the position and orientation of parts in SolveSpace in many different ways. In general, though, it should almost always be possible to constrain the parts with same-orientation, point-coincident, and point-on-face constraints only. Note in particular that it's not possible to place the position and orientation (six degrees of freedom) of a part using two point-coincident constraints. It seems like this should work, because the part initially has six degrees of freedom, and each point-coincident constraint removes three degrees of freedom. But the part, with those constraints, would obviously still be free to rotate about the line connecting the two constrained points. So that combination of constraints fails to fully constrain the part's rotation, and overconstrains the part elsewhere. It is therefore invalid. Place the other side of the box by any method; for example by importing it again and using a same-orientation and point-coincident constraint, or by stepping and repeating the side that we've just place twice, or in some other way. The assembly is now complete. We can view it on-screen, and produce isometric (View → Nearest Isometric View) or top, bottom and side (View → Nearest Ortho View) views of all the parts. We can suppress the display of a part by changing that setting in its text window screen. For example, to hide the base, we would click the home link at the top of the text window, and then choose its group—which in our assembly was the first import group, g003-import—from the list of groups. We then click the box labeled \"suppress this group's solid model\" to check it. To show that part again, we click that box again to uncheck it. We can verify that no parts interfere by choosing Analyze → Show Interfering Parts. If any parts interfere, then red lines will be drawn to indicate the location of the interference. (Note that this operation works on the triangle mesh, and not the exact NURBS surfaces; this means that it is guaranteed to work only for plane surfaces, and might report an erroneous interference for a round pin in a round hole.) Note that Analyze → Show Naked Edges will show many errors. This is expected, and not a problem. In our assembly, we have many places where two parts lie against each other exactly. The parts are supposed to fit together exactly, so this is the desired behavior; but a mesh that has two triangles exactly coplanar with each other is an error, so the \"STL check\" properly fails. For assemblies, Show Naked Edges is not typically meaningful; use Show Interfering Parts instead. We can export views of the assembly in the same way that we would export a view of a part. For example, we can choose File → Export View to produce a hidden-line-removed PDF, as shown below. (We had been working with parallel projections of the model so far, but this drawing has some perspective. We added this by choosing View → Use Perspective Projection. To adjust the amount of perspective, change the perspective factor in the configuration screen. The configuration screen is reachable from the link at the bottom of the home screen in the text window.) We can make changes to one of the parts, and then regenerate the assembly (by choosing Edit → Regenerate All, or by closing and reopening the file). The changes will propagate into our assembly, and with a careful choice of constraints, the parts will remain assembled in the desired configuration. This completes our tutorial. The assembly is also available for download: box-asm.zip Note that if you download the assembly, then it is necessary to extract all the part files to the same directory as the assembly file before attempting to open the assembly file. The assembly file does not contain a copy of the parts, so the program must rescan the part files every time it regenerates. To learn more about SolveSpace, including the assembly features, see the other tutorials or the reference manual."},{"url":"./2016fall-qi-zhong.html","title":"2016Fall 期中","tags":"Misc","text":"期中週除了自評以外，這學期多了個組員互評，超酷的！ 之後又有個Onshape的零件繪製，體驗一下目前最新的可攜式繪圖軟體 How to Use the Onshape College Curriculum A Note For Instructors Welcome! This 12-week curriculum is designed to introduce college/university students to Computer-Aided Design (CAD) using the Onshape \"Full-Cloud CAD\" platform. The skills learned in this material are easily transferable to any other parametric CAD system. This curriculum is made up of three main sections: Introduction and Basic Concepts (Weeks 1-5): A medley of small projects that introduces students to the primary lessons of 3D CAD and how to use Onshape's basic features. Bluetooth Speaker Project (Weeks 6-8): A larger project to guide students through realistic team-based design processes. Food Processor / Mini Chopper (Weeks 9-12): Another large project that teaches true top-down design from beginning to end with a focus on design for manufacturing (DFM) and full design documentation. Each week, there is a lesson plan, homework, and assessment covering a number of topics. The lesson plan contains step-by-step instructions on completing specific tasks, as well as short exercises that students are expected to complete during class or at home. The homework contains longer exercises similar to the in-class exercises, and the assessments contains 5 conceptual questions about the corresponding lesson; both are designed to reinforce the topics covered in the lesson plans. The assessments provide you, the instructor, a jump-off point, where you can begin to think of additional questions as necessary. The external folder (\"Onshape College Curriculum - External\") contains two folders: \"Assessment Answers\" and \"Onshape College Curriculum - Student Materials\". We suggest you only share the link to \"Onshape College Curriculum - Student Materials\" with your students. This link is reproduced below: https://drive.google.com/open?id=0B6dRZf2l-modX0oyMnNWTW56LTg A brief overview of the topics covered in each week can be found here: \"College Curriculum Outline.\" In addition, we have included a document called \"Public Document Links\" that contains links to public documents for everything that we reference in the lesson plans and homework. It might be beneficial for the students to see the final models in case they get stuck during the exercises. With all that said, we ask you to use this college curriculum not as a strict \"follow-along\" set of instructions, but rather as a flexible set of educational material to aid you in teaching CAD and design for manufacturing. Feel free to make your own copy of this Google folder and customize it in any way you wish. Re-order and manipulate the lesson plans, homeworks, and assessments to better accommodate your students. Lastly, we always welcome and encourage any feedback you may have regarding this curriculum so that we can further improve upon it. This will be a live folder and we will constantly update it as improvement requests come in. We hope that this curriculum will be beneficial to you and your students. We look forward to hearing what you think! Acknowledgements: Author: Jim Shaw is currently the Managing Director of Fastway Engineering, a firm dedicated to helping companies get the most out of their CAD/CAE software. Using hands-on, project-based curriculum, Fastway Engineering helps Designers, Engineers, Makers, and Manufacturers climb up the learning curve as fast as possible, hence the name, Fastway. Prior to that, he's designed, analyzed, tested, built, and driven a wide range of products. www.fastwayengineering.com Coauthors: Aya Suzuki is a summer intern on the Onshape Marketing Team. Currently pursuing a bachelor's degree in mechanical engineering and a minor in architectural design from MIT, she first became interested in teaching when she started tutoring mathematics and physics in high school. She continued on to make educational material on design methods as an undergraduate researcher at the MIT Ideation Laboratory, and is now pursuing her own research at the MIT Newman Laboratory for Biomechanics and Human Rehabilitation. 1 Noa Flaherty began teaching engineering concepts in the seventh grade, when he taught robotics to elementary, middle, and high schools until going off to college, where he earned bachelor's degrees in mechanical engineering and management from MIT. He started off at Onshape as an intern on the Research and Development team and is now on Onshape's Marketing Team full time, which leads Onshape's Education and Community programs, user onboarding and engagement, marketing operations, and assists in customer success and training."},{"url":"./2016fall-114-ling-jian-hui-zhi.html","title":"2016Fall 11/4 零件繪製","tags":"Misc","text":"2016 11 09 12 52 01 308 from ben on Vimeo ."},{"url":"./2016fall-1027-bi-ji.html","title":"2016Fall 10/27 筆記","tags":"Misc","text":"一位機械設計工程師的工作內容為: 參與機械設計討論及制定之會議 進行機械設計並輸出設計文件( 機器圖紙、外購件清單、機器操作說明書等) 協助機器製造、安裝等後續工作，並與相關部門做溝通 針對測試有誤之設計不良原因做調整改善 改良舊機台或設計新機台以適應新產品之生產需求 學習市場新技術並適時將新技術引進企業 而 Tesla 公司在招聘 Mechanical Design Engineer 時, 則列出一位機械設計工程師的角色、職責與要求如下: The Role Tesla Motors is committed to hiring and developing the top engineers in any given discipline. Our world-class engineering teams operate with a non-conventional automotive product development philosophy of high interdisciplinary collaboration, flat organizational structure and technical contribution at all levels. You will be expected to challenge and to be challenged, to create, to innovate. These jobs are not for everyone. You must have a genuine passion for engineering the best electric vehicles in the world. You must want to work in a fast-paced, entrepreneurial company. We are building real products. This must excite you. You must be a builder. You'll work alongside accomplished, world-renowned engineers on perhaps the most exciting automotive programs in existence today. Mechanical engineering within the Power Electronics team requires and offers a very high level of collaboration with electrical engineers and firmware engineers. Our systems typically deliver very high currents to enable our vehicles to go faster and charge faster than any other car ever developed in the mass market. Power electronics is the core of every EV. Our systems control the flow of electrons from the wall to the battery and eventually to the motor. Responsibilities Design and development of components to charge and drive Model S and future Tesla vehicles. CAD design of plastics, sheet metal, die castings, etc. Work with Electrical engineers and PCBA designers to integrate components into electromechanical systems. Thermal and mechanical modeling and testing of components. Validation of components in bench and vehicle configuration. Collaboration with manufacturing engineers and suppliers to transition concepts to production. Requirements Demonstrated successful experience in mechanical engineering within a product design and manufacturing environment. Experience with product and process validation. Detail oriented personality with solid documentation and reporting skills. 0-2 years mechanical engineering experience. Proficiency in CAD modeling, CATIA v5 experience highly valued but not required. MS or BS in Mechanical Engineering, or equivalent in experience and exceptional ability 至於 Ingersoll Rand 公司在招聘 Computer Aided Designer, 則列出下列訊息: SUMMARY Responsible for creating computer aided design (CAD) drawings using standard CAD digitizing techniques and skills. Also responsible for the system graphics required to support automation systems design. ESSENTIAL FUNCTIONS AND RESPONSIBILITIES include the following. Other functions may be assigned. Applies computer aided design technology to engineering principles and practices. Incorporates knowledge of Trane product design and installation to CAD design process. Prepares accurately detailed layouts to produce engineering drawing including wiring and installation details. Reads blueprints and provides site drawings according to specifications. Creates new CAD files from marked up templates or sketches. Creates bill of material to be included on drawings from information provided by Project Engineers. Revise existing HVAC mechanical or control CAD files from red-lined to as-built status. Creates new static background files from existing CAD files or sketches. Archives CAD files for warranty transition. Types up and imports damper and valve schedules. Types up and imports sequences of operations. Interacts with appropriate staff to answer questions and resolve potential concerns. Works with other team members including engineers and technicians to obtain concise information necessary to the design process and answer questions or provide information for the installation process. Keeps abreast of information regarding Trane products, installation and design. Completes drawings according to scheduled deadlines. Flexibility to work overtime/weekends, as needed. QUALIFICATIONS To perform this job successfully, an individual must be able to perform each essential duty satisfactorily. The requirements listed below are representative of the knowledge, skill, and/or ability required. Reasonable accommodations may be made to enable individuals with disabilities to perform the essential functions. EDUCATION and/or EXPERIENCE An Associates Degree from college or technical school in Computer-Aided Design or Drafting; or at least six (6) months related experience and/or training; or equivalent combination of education and experience. Working knowledge of AutoCAD or other computer aided design, Microsoft Office software required. HVAC/technical work experience preferred. LANGUAGE SKILLS Ability to read and interpret documents such as specifications, plans, operating and maintenance instructions, and procedure manuals. Ability to write routine reports and correspondence. Ability to speak effectively before groups of customers or employees of organization. MATHEMATICAL SKILLS Ability to apply concepts such as fractions, percentages, ratios, and proportions to practical situations. REASONING ABILITY Ability to solve practical problems and deal with a variety of concrete variables in situations where only limited standardization exists. Ability to interpret a variety of instructions furnished in written, oral, diagram, or schedule form. PHYSICAL DEMANDS The physical demands described here are representative of those that must be met by an employee to successfully perform the essential functions of this job. Reasonable accommodations may be made to enable individuals with disabilities to perform the essential functions. While performing the duties of this job, the employee is frequently required to stand, walk, and sit; and to use hands to finger, handle, and feel. The employee is occasionally required to reach with hands and arms; and stoop, kneel, crouch, or crawl. The employee must occasionally lift and/or move up to 25 pounds. Specific vision abilities required by this job include close vision, depth perception, and ability to adjust focus. WORK ENVIRONMENT The work environment characteristics described here are representative of those an employee encounters while performing the essential functions of this job. Reasonable accommodations may be made to enable individuals with disabilities to perform the essential functions. This position typically works in an office environment. The noise level in the work environment is usually moderate. We are committed to helping you reach your professional, personal and financial goals. We offer competitive compensation that aligns with our business strategies and comprehensive benefits to help you live your healthiest. We are committed to building an inclusive and diverse culture that engages as well as values the different backgrounds and experiences of our employee, which, in turn, spurs innovation, generates creative solutions and enhances our customer relations."},{"url":"./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html","title":"2016Fall 機械設計主題教學","tags":"Misc","text":"知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能."}]};